#  функция применяющая функцию расстояния на все объекты выборки и заданную
# точку z
dist_points(petals, z, euclidean_distance)
# выбираем индекс минимального элемента dist_points
min_index <- which(dist_points == min(dist_points))
# определяем класс элемента min_index
b_class <- iris[min_index, 5]
return(b_class)
}
for (x in seq(1, 7, 0.1))
{
for (y in seq(-1, 3, 0.1))
{
# классифицируемая точка
z = c(x, y)
# исключаем классификацию точек выборки
if (any(sapply(points, function(v) all(v == z)))) next
# применяем knn и определяем класс
class = knn_1(z)
# рисуем точку на графике
points(z[1], z[2], col = iris_colors[class], pch = 20)
}
}
source("functions.R")
# цвета классов
colors <- c("setosa" = "red", "versicolor" = "green3","virginica" = "blue")
# параметры объектов выборки
petals <- iris[, 3:4]
# рисуем ирисы фишера
plot(petals, pch=21, bg=iris_colors[iris$Species], col=colors[iris$Species], asp=1)
# функция knn с k = 1
knn_1 <- function(z) {
#  функция применяющая функцию расстояния на все объекты выборки и заданную
# точку z
dist_points(petals, z, euclidean_distance)
# выбираем индекс минимального элемента dist_points
min_index <- which(dist_points == min(dist_points))
# определяем класс элемента min_index
b_class <- iris[min_index, 5]
return(b_class)
}
for (x in seq(1, 7, 0.1))
{
for (y in seq(-1, 3, 0.1))
{
# классифицируемая точка
z = c(x, y)
# исключаем классификацию точек выборки
if (any(sapply(points, function(v) all(v == z)))) next
# применяем knn и определяем класс
class = knn_1(z)
# рисуем точку на графике
points(z[1], z[2], col = iris_colors[class], pch = 20)
}
}
source("functions.R")
# цвета классов
colors <- c("setosa" = "red", "versicolor" = "green3","virginica" = "blue")
# параметры объектов выборки
petals <- iris[, 3:4]
# рисуем ирисы фишера
plot(petals, pch=21, bg=iris_colors[iris$Species], col=colors[iris$Species], asp=1)
# функция knn с k = 1
knn_1 <- function(z) {
#  функция применяющая функцию расстояния на все объекты выборки и заданную
# точку z
dist_points(petals, z, euclidean_distance)
# выбираем индекс минимального элемента dist_points
min_index <- which(dist_points == min(dist_points))
# определяем класс элемента min_index
b_class <- iris[min_index, 5]
return(b_class)
}
for (x in seq(1, 7, 0.1))
{
for (y in seq(-1, 3, 0.1))
{
# классифицируемая точка
z = c(x, y)
# исключаем классификацию точек выборки
if (any(sapply(points, function(v) all(v == z)))) next
# применяем knn и определяем класс
class = knn_1(z)
# рисуем точку
points(z[1], z[2], col = iris_colors[class], pch = 20)
}
}
source("functions.R")
petals <- iris[,3:4]
classes <- iris[,5]
# функция классификации выбирает возвращает класс который встречается максимальное количество раз среди первых k
# отсортированных дистанций
knn <- function(sort_distances, k) {
return(names(which.max(table(names(sort_distances[1:k])))))
}
# функция скользящего контроля для определения оптимального k, классифицирует каждую точку выборки подставляя разные k
loo <- function(points, classes) {
# dim - определяет размерность матрицы (x,y), [1] - количество строк(150)
size_y <- dim(points)[1]
# rep(x,y) повторяет x y раз, следовательно создаем список из 149 элементов
# 149 так как loo проверяет каждый элемент выборки следовательно один занят
l <- rep(0, size_y-1)
for (i in 1:size_y) {
# z проверяемая точка из списка объектов
z <- points[i,]
# дистанции между объектами и проверяемой точкой
distances <- dist_points(points, z, euclidean_distance)[-i]
# присваеваем классы дистанциям
names(distances) <- classes[-i]
# сортировка дистанций от меньшего к большему
sort_distances <- sort(distances)
# проверяем количество ошибок классификации
for (k in 1:size_y-1) {
# если классифицированный элемент совпадает с реальным классом то оставляем 0,
# иначе прибавляем 1
l[k] <- l[k]+ifelse(knn(sort_distances, k) == classes[i], 0, 1)
}
}
# делим l на 150 для удобства отображения на графике
l <- l / size_y
# определяем оптимальный k
optimal_k <- which.min(l)
# отрисовка LOO
plot(1:length(l), l, type = "l", main="LOO")
# отрисовка точки k на графике loo
points(optimal_k, l[optimal_k], pch = 20, col = "blue")
text(optimal_k, l[optimal_k]+0.1, labels = paste("K=", optimal_k, " | LOO = ", round(l[optimal_k], 2)), pos = 4, col = "blue")
# возвращаем оптимальный k для дальнейшего построения карты классификации
return(optimal_k)
}
# цвета классов
colors <- c("setosa" = "red", "versicolor" = "green3","virginica" = "blue")
# функция для отображения нескольких графиков на одной странице
par(mfrow = c(1, 2))
# вызов функции loo, определение оптимального k
optimal_k <- loo(petals, classes)
# отрисовка стандартной выборки ирисов Фишера
plot(petals, bg = colors[iris$Species], pch = 21, asp = 1, main="Optimal KNN")
# построение карты классификации
# цикл для горизонтали
for (x in seq(1, 7, 0.1))
{
# цикл для вертикали
for (y in seq(-1, 3, 0.1))
{
# классифицируемая точка
z <- c(x, y)
if (any(sapply(points, function(v) all(v == z)))) next
# дистанции между объектами и проверяемой точкой
distances <- dist_points(petals, z, euclidean_distance)
# присваеваем классы дистанциям
names(distances) <- classes
# сортировка дистанций от меньшего к большему
sort_distances <- sort(distances)
# определяем класс точки
bclass <- knn(sort_distances, optimal_k)
# рисуем классифицированную точку
points(z[1], z[2], col = colors[bclass], pch = 20)
}
}
source("functions.R")
# цвета классов
colors <- c("setosa" = "red", "versicolor" = "green3","virginica" = "blue")
# параметры объектов выборки
petals <- iris[, 3:4]
# рисуем ирисы фишера
plot(petals, pch=21, bg=iris_colors[iris$Species], col=colors[iris$Species], asp=1)
# функция knn с k = 1
knn_1 <- function(z) {
#  функция применяющая функцию расстояния на все объекты выборки и заданную
# точку z
distances <- dist_points(petals, z, euclidean_distance)
# выбираем индекс минимального элемента dist_points
min_index <- which(distances == min(distances))
# определяем класс элемента min_index
b_class <- iris[min_index, 5]
return(b_class)
}
for (x in seq(1, 7, 0.1))
{
for (y in seq(-1, 3, 0.1))
{
# классифицируемая точка
z = c(x, y)
# исключаем классификацию точек выборки
if (any(sapply(points, function(v) all(v == z)))) next
# применяем knn и определяем класс
class = knn_1(z)
# рисуем точку
points(z[1], z[2], col = iris_colors[class], pch = 20)
}
}
source("functions.R")
# цвета классов
colors <- c("setosa" = "red", "versicolor" = "green3","virginica" = "blue")
# параметры объектов выборки
petals <- iris[, 3:4]
# рисуем ирисы фишера
plot(petals, pch=21, bg=iris_colors[iris$Species], col=colors[iris$Species], asp=1)
# функция knn с k = 1
knn_1 <- function(z) {
#  функция применяющая функцию расстояния на все объекты выборки и заданную
# точку z
distances <- dist_points(petals, z, euclidean_distance)
# выбираем индекс минимального элемента dist_points
min_index <- which(distances == min(distances))
# определяем класс элемента min_index
b_class <- iris[min_index, 5]
return(b_class)
}
for (x in seq(1, 7, 0.1))
{
for (y in seq(-1, 3, 0.1))
{
# классифицируемая точка
z = c(x, y)
# исключаем классификацию точек выборки
if (any(sapply(points, function(v) all(v == z)))) next
# применяем knn и определяем класс
class = knn_1(z)
# рисуем точку
points(z[1], z[2], col = colors[class], pch = 20)
}
}
source("functions.R")
# цвета классов
colors <- c("setosa" = "red", "versicolor" = "green3","virginica" = "blue")
# параметры объектов выборки
petals <- iris[, 3:4]
# рисуем ирисы фишера
plot(petals, pch=21, bg=iris_colors[iris$Species], col=colors[iris$Species], asp=1)
# функция knn с k = 1
knn_1 <- function(z) {
#  функция применяющая функцию расстояния на все объекты выборки и заданную
# точку z
distances <- dist_points(petals, z, euclidean_distance)
# выбираем индекс минимального элемента dist_points
min_index <- which(distances == min(distances))
# определяем класс элемента min_index
b_class <- iris[min_index, 5]
return(b_class)
}
for (x in seq(1, 7, 0.1))
{
for (y in seq(-1, 3, 0.1))
{
# классифицируемая точка
z = c(x, y)
# исключаем классификацию точек выборки
if (any(sapply(points, function(v) all(v == z)))) next
# применяем knn и определяем класс
bclass = knn_1(z)
# рисуем точку
points(z[1], z[2], col = colors[bclass], pch = 20)
}
}
source("functions.R")
# цвета классов
colors <- c("setosa" = "red", "versicolor" = "green3","virginica" = "blue")
# параметры объектов выборки
petals <- iris[, 3:4]
# рисуем ирисы фишера
plot(petals, pch=21, bg=iris_colors[iris$Species], col=colors[iris$Species], asp=1)
# функция knn с k = 1
knn_1 <- function(z) {
#  функция применяющая функцию расстояния на все объекты выборки и заданную
# точку z
distances <- dist_points(petals, z, euclidean_distance)
# выбираем индекс минимального элемента dist_points
min_index <- which(distances == min(distances))
# определяем класс элемента min_index
b_class <- iris[min_index, 5]
return(b_class)
}
source("functions.R")
# цвета классов
colors <- c("setosa" = "red", "versicolor" = "green3","virginica" = "blue")
# параметры объектов выборки
petals <- iris[, 3:4]
# рисуем ирисы фишера
plot(petals, pch=21, bg=colors[iris$Species], col=colors[iris$Species], asp=1)
# функция knn с k = 1
knn_1 <- function(z) {
#  функция применяющая функцию расстояния на все объекты выборки и заданную
# точку z
distances <- dist_points(petals, z, euclidean_distance)
# выбираем индекс минимального элемента dist_points
min_index <- which(distances == min(distances))
# определяем класс элемента min_index
b_class <- iris[min_index, 5]
return(b_class)
}
for (x in seq(1, 7, 0.1))
{
for (y in seq(-1, 3, 0.1))
{
# классифицируемая точка
z = c(x, y)
# исключаем классификацию точек выборки
if (any(sapply(points, function(v) all(v == z)))) next
# применяем knn и определяем класс
bclass = knn_1(z)
# рисуем точку
points(z[1], z[2], col = colors[bclass], pch = 20)
}
}
source("functions.R")
# цвета классов
colors <- c("setosa" = "red", "versicolor" = "green3","virginica" = "blue")
# параметры объектов выборки
petals <- iris[, 3:4]
# рисуем ирисы фишера
plot(petals, pch=21, bg=colors[iris$Species], col=colors[iris$Species], asp=1)
# функция knn с k = 1
knn_1 <- function(z) {
#  функция применяющая функцию расстояния на все объекты выборки и заданную
# точку z
distances <- dist_points(petals, z, euclidean_distance)
# выбираем индекс минимального элемента dist_points
min_index <- which(distances == min(distances))
# определяем класс элемента min_index
b_class <- iris[min_index, 5]
return(b_class)
}
for (x in seq(1, 7, 0.1))
{
for (y in seq(-1, 3, 0.1))
{
# классифицируемая точка
z = c(x, y)
# исключаем классификацию точек выборки
if (any(sapply(points, function(v) all(v == z)))) next
# применяем knn и определяем класс
bclass = knn_1(z)
# рисуем точку
points(z[1], z[2], col = colors[bclass], pch = 21)
}
}
source("functions.R")
# цвета классов
colors <- c("setosa" = "red", "versicolor" = "green3","virginica" = "blue")
# параметры объектов выборки
petals <- iris[, 3:4]
# рисуем ирисы фишера
plot(petals, pch=20, bg=colors[iris$Species], col=colors[iris$Species], asp=1)
# функция knn с k = 1
knn_1 <- function(z) {
#  функция применяющая функцию расстояния на все объекты выборки и заданную
# точку z
distances <- dist_points(petals, z, euclidean_distance)
# выбираем индекс минимального элемента dist_points
min_index <- which(distances == min(distances))
# определяем класс элемента min_index
b_class <- iris[min_index, 5]
return(b_class)
}
for (x in seq(1, 7, 0.1))
{
for (y in seq(-1, 3, 0.1))
{
# классифицируемая точка
z = c(x, y)
# исключаем классификацию точек выборки
if (any(sapply(points, function(v) all(v == z)))) next
# применяем knn и определяем класс
bclass = knn_1(z)
# рисуем точку
points(z[1], z[2], col = colors[bclass], pch = 21)
}
}
source("functions.R")
# цвета классов
colors <- c("setosa" = "red", "versicolor" = "green3","virginica" = "blue")
# параметры объектов выборки
petals <- iris[, 3:4]
# рисуем ирисы фишера
plot(petals, pch=20, bg=colors[iris$Species], col=colors[iris$Species], asp=1)
# функция knn с k = 1
knn_1 <- function(z) {
#  функция применяющая функцию расстояния на все объекты выборки и заданную
# точку z
distances <- dist_points(petals, z, euclidean_distance)
# выбираем индекс минимального элемента dist_points
min_index <- which(distances == min(distances))
# определяем класс элемента min_index
b_class <- iris[min_index, 5]
return(b_class)
}
for (x in seq(1, 7, 0.1))
{
for (y in seq(-1, 3, 0.1))
{
# классифицируемая точка
z = c(x, y)
# исключаем классификацию точек выборки
if (any(sapply(points, function(v) all(v == z)))) next
# применяем knn и определяем класс
bclass = knn_1(z)
# рисуем точку
points(z[1], z[2], col = colors[bclass], pch = 20)
}
}
source("functions.R")
# цвета классов
colors <- c("setosa" = "red", "versicolor" = "green3","virginica" = "blue")
# параметры объектов выборки
petals <- iris[, 3:4]
# рисуем ирисы фишера
plot(petals, pch=21, bg=colors[iris$Species], col=colors[iris$Species], asp=1)
# функция knn с k = 1
knn_1 <- function(z) {
#  функция применяющая функцию расстояния на все объекты выборки и заданную
# точку z
distances <- dist_points(petals, z, euclidean_distance)
# выбираем индекс минимального элемента dist_points
min_index <- which(distances == min(distances))
# определяем класс элемента min_index
b_class <- iris[min_index, 5]
return(b_class)
}
for (x in seq(1, 7, 0.1))
{
for (y in seq(-1, 3, 0.1))
{
# классифицируемая точка
z = c(x, y)
# исключаем классификацию точек выборки
if (any(sapply(points, function(v) all(v == z)))) next
# применяем knn и определяем класс
bclass = knn_1(z)
# рисуем точку
points(z[1], z[2], col = colors[bclass], pch = 20)
}
}
#вспомогательные функции
source(file = "help.R", encoding = "UTF-8")
mc.PW.kernel = mc.kernel.G #использовать ЭТО ядро
#PW
mc.PW = function(distances, u, h) {
weights = mc.PW.kernel(distances / h)
classes = unique(names(distances))
weightsByClass = sapply(classes, mc.sumByClass, weights)
if (max(weightsByClass) == 0) return("") #ни одна точка не попала в окно
return(names(which.max(weightsByClass)))
}
#LOO
mc.LOO.PW = function(points, classes, hValues) {
n = dim(points)[1]
loo = rep(0, length(hValues))
for (i in 1:n) {
u = points[i,]
sample = points[-i,]
distances = mc.distances(sample, u)
names(distances) = classes[-i]
for (j in 1:length(hValues)) {
h = hValues[j]
classified = mc.PW(distances, u, h)
loo[j] = loo[j] + (classified != classes[i])
}
}
loo = loo / n
}
#Отрисовка LOO
mc.draw.LOO.PW = function(points, classes, hValues) {
loo = mc.LOO.PW(points, classes, hValues)
x = hValues
y = loo
plot(x, y, type = "l", main = "LOO для Парзеновского окна (PW)", xlab = "h", ylab = "LOO", col.lab = "blue")
h = hValues[which.min(loo)]
h.loo = round(loo[which.min(loo)], 4)
points(h, h.loo, pch = 19, col = "blue")
label = paste("h = ", h, "\n", "LOO = ", h.loo, sep = "")
text(h, h.loo, labels = label, pos = 3, col = "blue", family = "mono", font = 2)
return(h)
}
#Отрисовка карты классификации
mc.draw.PW = function(points, classes, colors, h) {
uniqueClasses = unique(classes)
names(colors) = uniqueClasses
x = points[, 1]
y = points[, 2]
xlim = plot.limits(x, 0.3)
ylim = plot.limits(y, 0.3)
plot(points, bg = colors[classes], pch = 21, asp = 1, xlim = xlim, ylim = ylim, main = "Карта классификации PW", col.lab = "blue") #Рисуем известные точки
#Классифицируем точки
step = 0.1
ox = seq(xlim[1], xlim[2], step)
oy = seq(ylim[1], ylim[2], step)
for (x in ox) {
for (y in oy) {
x = round(x, 1) #избегаем случаев 0.1 + 0.2 = 0.3000000004
y = round(y, 1) #избегаем случаев 0.1 + 0.2 = 0.3000000004
u = c(x, y)
if (mc.contains(points, u)) next #не классифицировать известные точки
distances = mc.distances(points, u)
names(distances) = classes
classified = mc.PW(distances, u, h)
#рисуем новую классифицированную точку
points(u[1], u[2], col = colors[classified], pch = 21) #u
}
}
legend("topright", legend = uniqueClasses, pch = 21, pt.bg = colors[uniqueClasses], xpd = T) #добавим легенду для большей ясности
}
#тестируем программу
test = function() {
petals = iris[, 3:4]
petalNames = iris[, 5]
par(mfrow = c(1, 2), xpd = T)
h = mc.draw.LOO.PW(petals, petalNames, hValues = seq(0.1, 2, 0.005))
mc.draw.PW(petals, petalNames, colors = c("red", "green3", "blue"), h = h)
}
test()
