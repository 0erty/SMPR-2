library(ggplot2)
# функция расстояния, принимает на вход координаты двух точек
# и считает между ними расстояние
euclidean_distance <- function(u, v) {
# корень из суммы квадрата разности элементов 'u' и 'v'
  sqrt(sum((u-v)^2))
}

#  функция применяющая функцию расстояния на все объекты выборки и заданную
# точку z
dist_points <- function(xl, z, dist_function) {
# apply аналог функции map в python применяет функцию(dist_function) к выборке
# xl, '1' означает построчное применение, '2' столбцовое, 'z' - доп параметр
# для функции dist_function
  apply(xl, 1, dist_function, z)
}


# TEST DONT WORK | | | |
#                V V V V
# loo - скользяищий контроль по элементно
# принимает на вход объекты и их классы
# определяет оптимальный k классифицируя каждую точку выборки и считая
# количество ошибок
loo <- function(points, classes) {
# dim - определяет размерность матрицы (x,y), [1] - количество строк(150)
  size_y <- dim(points)[1]
# rep(x,y) повторяет x y раз, следовательно создаем список из 149 элементов
# 149 так как loo проверяет каждый элемент выборки следовательно один занят
  l <- rep(0, size_y-1)

  for (i in 1:size_y) {
# z проверяемая точка из списка объектов
    z <- points[i,]
# дистанции между объектами и проверяемой точкой
    distances <- dist_points(points, z, euclidean_distance)[-i]
# присваеваем классы дистанциям
    names(distances) <- classes[-i]
# сортировка дистанций от меньшего к большему
    sort_distances <- sort(distances)
# проверяем количество ошибок классификации
    for (k in 1:size_y-1) {
# если классифицированный элемент совпадает с реальным классом то оставляем 0,
# иначе прибавляем 1
      l[k] <- l[k]+ifelse(knn(sort_distances, k) == classes[i], 0, 1)
    }
  }
# делим l на 150 для удобства отображения на графике
  l <- l / size_y
  return (l)
}
